<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ach: Synchronization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Synchronization </h1>  </div>
</div>
<div class="contents">
<p>Synchronization currently uses a simple mutex+condition variable around the whole shared memory block</p>
<p>Some idea for more complicated synchronization:</p>
<p>Our synchronization for shared memory could work roughly like a read-write lock with one one additional feature. A reader may choose to block until the next write is performed.</p>
<p>This behavior could be implemented with a a state variable, a mutex, two condition variables, and three counters. One condition variable is for writers, and the other for readers. We count active readers, waiting readers, and waiting writers. If a writer is waiting, readers will block until it finishes.</p>
<p>It may be possible to make these locks run faster by doing some CASs on the state word to handle the uncontended case. Of course, figuring out how to make this all lock free would really be ideal...</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>synchronization should be robust against processes terminating</dd></dl>
<p>Mostly Lock Free Synchronization:</p>
<ul>
<li>Have a single word atomic sync variable</li>
<li>High order bits are counts of writers, lower bits are counts of readers</li>
<li>Fast path twiddles the counts. Slow path deals with a mutex and cond-var.</li>
<li>downside: maybe no way for priority inheritance to happen...</li>
</ul>
<p>Other Fancy things:</p>
<ul>
<li>Use futexes for waiting readers/writers</li>
<li>Use eventfd to signal new data </li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Nov 15 2012 01:27:04 for ach by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
